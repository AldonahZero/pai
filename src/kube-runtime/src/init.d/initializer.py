#!/usr/bin/python

# Copyright (c) Microsoft Corporation
# All rights reserved.
#
# MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
# to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function

import os
import sys
import collections
import logging
import argparse
import json
import yaml
import subprocess
from shutil import copyfile

logger = logging.getLogger(__name__)

def run_script(script_path, parameters, output_paths):
    args = [script_path, "{}".format(parameters)]
    args += output_paths
    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        line = proc.stdout.readline()
        if not line:
            break
        line = line.encode("UTF-8").strip()
        logger.info(line)
    proc.wait()
    if proc.returncode:
        logger.error("failed to run %s, error code is %s", script_path, proc.returncode)


def init_deployment(jobconfig, commands):
    """Inject preCommands and postCommands form deployment.

    Args:
        jobconfig: Jobconfig object generated by praser.py from framework.json.
    """
    
    if 'defaults' not in jobconfig or 'deployments' not in jobconfig or 'deployment' not in jobconfig['defaults']:
        logger.info("No suitable deployment found in jobconfig. Skipping")
        return None
    else:
        deployment_name = jobconfig['defaults']['deployment']
        taskrole_name = os.environ.get("FC_TASKROLE_NAME")
        for deployment in jobconfig['deployments']:
            if deployment['name'] == deployment_name and taskrole_name in deployment['taskRoles']:
                # Inject preCommands and postCommands
                commands[0].append("\n".join(deployment['taskRoles'][taskrole_name]['preCommands']))
                commands[1].insert(0, "\n".join(deployment['taskRoles'][taskrole_name]['postCommands']))


def init_plugins(jobconfig, commands, work_dir):
    """Init plugins from jobconfig.

    Args:
        jobconfig: Jobconfig object generated by praser.py from framework.json.
    """

    current_taskrole_name = os.environ.get("FC_TASKROLE_NAME")

    for index in range(len(jobconfig["extras"]["com.microsoft.pai.runtimeplugin"])):
        plugin = jobconfig["extras"]["com.microsoft.pai.runtimeplugin"][index]
        # Check taskroles
        if "taskroles" in plugin and current_taskrole_name not in plugin["taskroles"]:
            continue

        plugin_name = plugin["plugin"]
        plugin_base_path = "{}/plugins/{}".format(work_dir, plugin_name)

        parameters = plugin.get("parameters", "")
        output_paths = []

        with open("{}/desc.yaml".format(plugin_base_path), "r") as f:
            plugin_desc = yaml.load(f)

        # Inject call to runtime. Consider plugin call sequence, first in pre-script last in post-script
        if 'pre-template' in plugin_desc:
            dest_path = "{}/runtime.d/pre{}.sh".format(work_dir, index)
            copyfile("{}/{}".format(plugin_base_path, plugin_desc['pre-template']), dest_path)
            os.chmod(dest_path, 0o777)
            commands[0].append(dest_path)
            output_paths.append(dest_path)

        if 'post-template' in plugin_desc:
            dest_path = "{}/runtime.d/post{}.sh".format(work_dir, index)
            copyfile("{}/{}".format(plugin_base_path, plugin_desc['post-template']), dest_path)
            os.chmod(dest_path, 0o777)
            commands[1].insert(0, dest_path)
            output_paths.append(dest_path)

        # Run init script
        if 'init-script' in plugin_desc:
            run_script("{}/{}".format(plugin_base_path, plugin_desc['init-script']), parameters, output_paths)


if __name__ == "__main__":
    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(message)s",
        level=logging.INFO,
    )
    parser = argparse.ArgumentParser()
    parser.add_argument("jobconfig_yaml", help="jobConfig.yaml generated by parser.py from framework.json")
    parser.add_argument("work_dir", help="pai work dir")
    args = parser.parse_args()

    PAI_WORK_DIR = args.work_dir

    logger.info("loading yaml from %s", args.jobconfig_yaml)
    with open(args.jobconfig_yaml) as j:
        jobconfig = yaml.load(j)

    commands = [[], []]
    init_plugins(jobconfig, commands, PAI_WORK_DIR)
    init_deployment(jobconfig, commands)

    with open("{}/runtime.d/precommands.sh".format(PAI_WORK_DIR), 'a+') as f:
        f.write("\n".join(commands[0]))

    with open("{}/runtime.d/postcommands.sh".format(PAI_WORK_DIR), 'a+') as f:
        f.write("\n".join(commands[1]))
